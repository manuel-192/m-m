#!/bin/bash

# Create a local repo from certain AUR PKGBUILDs.

Pushd()  { pushd "$@" >/dev/null ; }
Popd()   { popd  "$@" >/dev/null ; }
echo2()  { echo "$@" >&2 ; }
printf2()  { printf "$@" >&2 ; }

echo2v()   { [ $verbose = yes ] && echo2   "$@" ; }
printf2v() { [ $verbose = yes ] && printf2 "$@" ; }

ASSERT() { "$@" || DIE "'$*' failed" ; }
DIE()    {
    local msg="$progname: error: $1"
    echo2 "$msg"

    local date="$(date +%Y%m%d-%H%M)"
    echo "$date: $msg" > "$errlog"
    exit 1
}
INFO() {
    echo2 "==> $progname: info: $@"
}

AddPackagesToRepo() {
    local pkg pkgs=() sigs=()
    echo2 "==> Adding built packages to repo db"
    if [ -z "$SIGNER" ] ; then
        if [ $dryrun = no ] || [ $force_rebuild = yes ] ; then
            INFO "packages will not be signed"
        fi
    fi
    for pkg in "$@" ; do
        echo2 "    -> $pkg"
        pkgs+=("$pkg")
        if [ -n "$SIGNER" ] ; then
            ASSERT gpg --local-user "$SIGNER" --output="$pkg.sig" --detach-sign "$pkg"
            sigs+=("$pkg".sig)
        fi
    done
    ASSERT repo-add "$REPONAME.db.tar.xz" "${pkgs[@]}" >/dev/null

    rm -f $REPONAME.{db,files}.tar.xz.old

    if [ $add_cache = yes ] ; then
        if [ -n "$SIGNER" ] ; then
            echo2 "==> add built packages to package cache: "
            sudo cp "${pkgs[@]}" "${sigs[@]}" /var/cache/pacman/pkg/
        else
            INFO "no signed packages, will not add to local cache"
        fi
    fi
    echo2 "==> done."
}

GetPkgbuildPkgname() {
    local PKGBUILD="$1"
    source "$PKGBUILD"
    echo "${pkgname}-${pkgver}-${pkgrel}-${arch[0]}.pkg.tar.zst"
}

BuildPackages() {
    local files file pkgs=() onepkgs=()
    local built=no
    local pkgname                 # pkgname = name in PKGNAMES array (a folder)
    local destructor
    local depsfile

    Pushd "$pkgbuilddir"
    
    for pkgname in "${build_needed[@]}" ; do
        [ -r "$pkgname/PKGBUILD" ] || DIE "no PKGBUILD for '$pkgname'"
        ASSERT Pushd "$pkgname"

        depsfile=/tmp/$pkgname.tmp.deps
        InstallMissingDeps $pkgname $depsfile

        printf2 "==> %-40s: Building..." "$pkgname"
        ASSERT makepkg -cf ${MAKEPKG_EXTRA_OPTS[$pkgname]} &> "$buildlog"
        echo2 "done."

        if [ $remove_deps = yes ] ; then
            RemoveInstalledDeps $pkgname $depsfile
        fi
        rm -f $depsfile

        destructor="${PKG_BEFORE_AFTER[$pkgname]}"                 # destructor should clean up
        if [ -n "$destructor" ] ; then
            case "$VERSION_COMPAT" in
                0) ASSERT "$destructor" --op=destruct ;;
                *) ASSERT "$destructor" after ;;
            esac
        fi
        onepkgs=()
        readarray -t files <<< $(ls -1 *.pkg.tar.zst 2>/dev/null)
        for file in "${files[@]}" ; do
            if [ ! -e "$repodir/$file" ] || [ "$force_rebuild" = "yes" ] ; then
                rm -f "$repodir/$file"{,.sig}
                onepkgs+=("$file")                        # these are new repo files
            fi
        done
        if [ ${#onepkgs[@]} -gt 0 ] ; then
            ASSERT cp "${onepkgs[@]}" "$repodir"          # copy built package files to the repo
            rm -f "${onepkgs[@]}"                         # cleanup
            built=yes
            pkgs+=("${onepkgs[@]}")
        fi

        ASSERT Popd
    done
    Popd   # "$pkgbuilddir"

    if [ "$built" = "yes" ] ; then
        AddPackagesToRepo "${pkgs[@]}"
    else
        echo2 "Nothing to do."
    fi
}

BuildNeeded() {
    # TODO: handle multipackage PKGBUILDs

    local pkgname="$1"
    local archive="$repodir/PKG_ARCHIVE"

    old_version=$(ls -1 "$repodir/$pkgname"-*.pkg.tar.zst 2>/dev/null)
    old_version=$(echo "$old_version" | tail -n1 | pkg-name-components --real EVR)
    [ -n "$old_version" ] || return 0

    new_version=$(LANG=C $helper_Sia "$pkgname" | grep -E "^Version[ ]+: " | awk '{print $NF}')
    [ -n "$new_version" ] || DIE "cannot determine the latest available version of package '$pkgname'"

    case "$(vercmp "$new_version" "$old_version")" in
        1)  mkdir -p "$archive"
            mv "$pkgname"-*.pkg.tar.zst{,.sig} "$archive" 2>/dev/null
            return 0
            ;;
        *)  return 1
            ;;
    esac
}

FetchPkgbuilds() {
    FetchAurPackage() {
        printf2v "...fetching"
        ASSERT $helper_Ga "$1"
        echo2v "...done."
    }

    local pkgname
    local constructor
    local old_version new_version

    Pushd "$pkgbuilddir"

    for pkgname in "${PKGNAMES[@]}" ; do
        printf2v "==> %-40s: " "$pkgname"
        if [ "$force_rebuild" = "no" ] ; then
            if ! BuildNeeded "$pkgname" ; then
                echo2v "OK ($old_version)"
                continue
            fi
            printf2v "update ($old_version --> $new_version)"
        else
            printf2v "forced ($old_version --> $new_version)"
        fi
        if [ $dryrun = no ] ; then
            build_needed+=("$pkgname")
            rm -rf "$pkgname"                        # remove possible old pkg folder
            FetchAurPackage "$pkgname" >/dev/null
            constructor="${PKG_BEFORE_AFTER[$pkgname]}"
            if [ -n "$constructor" ] ; then
                ASSERT Pushd "$pkgname"
                case "$VERSION_COMPAT" in
                    0) ASSERT "$constructor" --op=construct ;;
                    *) ASSERT "$constructor" before ;;
                esac
                Popd
            fi
        else
            echo2v ""
        fi
    done

    Popd  # "$pkgbuilddir"
}

FuncnameToPkgname() {     # convert "_name_" to "name"
    local name="$1"       # funcname
    name=${name:1}        # remove first char
    name=${name:: -1}     # remove last char
    echo "$name"
}

IsInPkgnames() {
    local -r pkgname="$1"
    printf "%s\n" "${PKGNAMES[@]}" | grep "^$pkgname$" >/dev/null
}

Add_BeforeAfter_func() {
    local -r funcname="$1"
    local -r pkgname="$(FuncnameToPkgname "$funcname")"
    IsInPkgnames "$pkgname" && PKG_BEFORE_AFTER[$pkgname]="$funcname"

    true  # do not fail sourceing the config file
}

GetPkgbuildValue() {
    local -r varname="$1"
    local -n retvar="$2"

    source PKGBUILD || return 1
    case "$varname" in
        depends)     retvar=("${depends[@]}") ;;
        makedepends) retvar=("${makedepends[@]}") ;;
        pkgrel)      retval="$pkgrel" ;;
        pkgver)      retval="$pkgver" ;;
        epoch)       retval="$eopch" ;;
        *) return 1 ;;
    esac
}
PutPkgbuildValue() {
    local -r varname="$1"
    local -r value="$2"
    sed -i PKGBUILD -e "s|^$varname=.*|$varname='$value'|"
}

MissingDeps() {
    local -r pkgname_dir="$1"
    local -r varname="$2"
    local DEPS=()
    local pkgs=()

    GetPkgbuildValue $varname DEPS || return 1

    for pkg in "${DEPS[@]}" ; do
        case "$pkg" in
            *">"*) pkg=${pkg%%>*} ;;
            *"="*) pkg=${pkg%%=*} ;;
            *"<"*) pkg=${pkg%%<*} ;;
        esac
        expac -Q %n $pkg &>/dev/null || pkgs+=($pkg)
    done

    printf "%s\n" "${pkgs[@]}"
}

InstallMissingDeps() {
    local -r pkgname_dir="$1"
    local depsfile="$2"
    local install=()

    install+=($(MissingDeps "$pkgname_dir" depends))     || return 1
    install+=($(MissingDeps "$pkgname_dir" makedepends)) || return 1

    if [ ${#install[@]} -gt 0 ] ; then
        local list=$(printf "   %s\n" "${install[@]}")
        printf "Package %s, installing dependencies:\n%s\n" "$pkgname_dir" "$list" >&2
        echo "${install[*]}" > $depsfile
        sudo pacman -S "${install[@]}"
    fi
}

RemoveInstalledDeps() {
    local -r pkgname_dir="$1"
    local depsfile="$2"
    local remove=$( test -r $depsfile && cat $depsfile )

    if [ -n "$remove" ]  ; then
        local list=$(printf "   %s\n" $remove)
        printf "Package %s, removing dependencies:\n%s\n" "$pkgname_dir" "$list" >&2
        echo "Removing dependencies $remove:" >&2
        sudo pacman -R $remove
    fi
}

#### Backwards compatibility stuff:
# VERSION_COMPAT == 0:
Add_before-after_func()  { Add_BeforeAfter_func "$@" ; }
PutPkgbuildValueSimple() { PutPkgbuildValue "$@" ; }

Main() {
    local progname="local-repo-manager"
    local conf="/etc/$progname.conf"

    # to be filled by the config file
    local REPONAME=""             # the reponame for /etc/pacman.conf
    local SIGNER=""               # the package signer, for option --local-user in gpg
    local WORKDIR=""              # where the package building occurs
    local PACKAGED_BY=""          # who built the packages (gpg)
    local PKGNAMES=()             # AUR package names for the local repo
    local VERSION_COMPAT=0        # compatibility of the config file, 0=first
    declare -A PKG_BEFORE_AFTER   # package specific functions before and after 'makepkg' (like constructor and destructor in C++)
    declare -A MAKEPKG_EXTRA_OPTS

    source "$conf" || return 1    # $conf file must fill the required variables above

    local repodir="$WORKDIR"    # "$PWD"
    local pkgbuilddir="$WORKDIR/PKGBUILDS"
    local buildlog="$HOME/.cache/$progname.buildlog"
    local errlog="$HOME/.cache/$progname.errlog"
    local build_needed=()
    local force_rebuild=no
    local verbose=no
    local add_cache=no
    local dryrun=no
    local remove_deps=no
    local arg

    for arg in "$@" ; do
        case "$arg" in
            -h | --help)
                cat <<EOF
Usage:    $progname [options]
Options:
          -b, --build            Build updated packages. Default.
          -f, --build-force      Re-build all packages.
          -c, --add-cache        Add builts packages to system's package cache.
          -n, --dryrun           Show what would be done, but change nothing. Implies --verbose.
          -v, --verbose          More verbose output.
          --rmdeps               Remove dependencies installed during build.
EOF
                ;;

            -f | --build-force) force_rebuild=yes ;;
            -v | --verbose)     verbose=yes ;;
            -c | --add-cache)   add_cache=yes ;;
            -n | --dryrun | --dryrun-local)
                                dryrun=yes; verbose=yes ;;
            -b | --build)       dryrun=no ;;
            --rmdeps)           remove_deps=yes ;;
        esac
    done

    local helper_Sia="yay -Sia"   # because yay does this faster than paru
    local helper_Ga="paru -Ga"    # because yay does not detect failure as it should

    [ -n "$REPONAME" ]        || DIE "REPONAME in the config file is empty or not set"
    [ -n "$WORKDIR" ]         || DIE "WORKDIR is missing, cannot build packages"
    [ ${#PKGNAMES[@]} -gt 0 ] || DIE "PKGNAMES array in the config file is empty or not set"

    [ -n "$PACKAGED_BY" ]     && export PACKAGER="$PACKAGED_BY"
    

    cd "$WORKDIR"

    FetchPkgbuilds

    echo2v ""

    BuildPackages
}

Main "$@"
