#!/bin/bash

# Rank Arch mirrors.

echo2()    { echo "$@" >&2 ; }
echo2i()   { echo "$@" | Indent >&2 ; }
printf2()  { printf "$@" >&2 ; }
Verbose2() { [ "$verbose" = "yes" ] && echo2 "==>" "$@" ; }

DIE() {
    echo2 "==> $progname: error: $1"
    [ "$2" != "stay" ] && exit 1
}
Indent() { sed 's|^|    |' ; }

Rank() {
    Verbose2 "Ranking, please wait ..."

    local url="https://archlinux.org/mirrorlist/?use_mirror_status=on"
    local data retval=0
    local xx

    for xx in "${countries[@]}" ; do
        url+="&country=$xx"
    done
    for xx in "${protocols[@]}" ; do
        url+="&protocol=$xx"
    done
    for xx in "${ip_versions[@]}" ; do
        url+="&ip_version=$xx"
    done

    data=$($fetchcmd "$url" 2>/dev/null)
    retval=$?
    case "$retval" in
        0) ;;
        *) DIE "'$fetchcmd $url' failed with code $retval" ;;
    esac

    local mirrors=$(echo "$data" | grep -Pv "^## |^##$|^$" | awk '{print $NF}')  # URLs of mirrors
    local ranked

    ranked=$(
        {
            local retcode result lastupdate fetch_time line url2

            echo "Mirror Last-update Fetch-time"
            echo "~~~~~~ ~~~~~~~~~~~ ~~~~~~~~~~"
            for url in $mirrors ; do
                Verbose2 "$url"
                # url2=$(echo "$url" | sed 's|$repo/os/$arch|lastupdate|')
                url2=${url/'$repo/os/$arch'/lastupdate}
                result=$(curl --fail -Lsm $download_timeout -w "%{time_total}" "$url2")  # fetch lastupdate, measure time
                retcode=$?
                if [ $retcode -eq 0 ] ; then
                    lastupdate=$(echo "$result" | head -n1)     # lastupdate time stamp as epoch
                    fetch_time=$(echo "$result" | tail -n1)     # fetch time
                    if [ "$time_as_datetime" = "yes" ] ; then
                        lastupdate=$(date --date="@$lastupdate" "+%Y%m%d-%H%M%S")
                    fi
                    line="$url $lastupdate $fetch_time"
                    IsOkMirror "$url2" && echo "$line"
                else
                    printf "==> %s failed, reason:\n%s\n" "$url" "$(curl-exit-code-to-string $retcode)" > /dev/stderr
                fi
            done | LC_ALL=C sort -g -k2r,2 -k3,3 | head -n$((max_mirrors_to_show+2)) | sed 's|[ \t]*$||'
        } )

    Verbose2 "Show ranking result"
    echo "$ranked" | column -t >&2

    SaveToFile
}

UserPreferredMirrors() {
    if [ ${#USER_PREFERRED_MIRRORS[@]} -gt 0 ] ; then
        printf "# User preferred -->\n"                       >> "$file"
        printf "Server = %s\n" "${USER_PREFERRED_MIRRORS[@]}" >> "$file"
        printf "# User preferred <--\n\n"                     >> "$file"
    fi
}

LineOfRepeatedChars() {
    local -n targetline="$1"
    local repeat_char="$2"
    local len="$3"
    builtin printf -v targetline "%.s$repeat_char" $(seq 1 $len)
}

HeadingAndDataToFile() {
    local file="$1"
    local date="$(date -u "+%Y-%m-%d %H:%M") UTC"
    local line="### Arch Linux mirrorlist generated by $progname ###"
    local edgeline=""

    LineOfRepeatedChars edgeline "#" "${#line}"

    # heading
    cat <<EOF > "$file"
$edgeline
$line
$edgeline
# With: $cmdline
# When: $date
$edgeline

EOF
    # mirrors preferred by the user
    UserPreferredMirrors

    # data (mirrorlist)
    echo "$mirrorlist" >> "$file"

    # background info in verbose mode
    if [ "$verbose" = "yes" ] ; then
        printf "\n### Ranking data:\n"                 >> "$file"
        echo "$ranked" | sed 's|^|## |' | column -t >&2 >> "$file"

        if [ $(stat -c %s "$rank_fails_file") -gt 0 ] ; then
            printf "\n### Ranking problems:\n"   >> "$file"
            cat $rank_fails_file | sed 's|^|### |' >> "$file"
        fi
    fi
}

SaveToFile() {
    if [ -n "$savefile" ] ; then
        local mirrorlist=$(echo "$ranked" | grep -Pv '^~~~|^Mirror' | awk '{print $1}' | sed 's|^|Server = |')

        printf2 "==> Writing $savefile ... "

        if touch "$savefile" 2>/dev/null ; then
            HeadingAndDataToFile "$savefile"
        else
            local tmpfile=$(mktemp)
            HeadingAndDataToFile "$tmpfile"
            su-c_wrapper bash -c "cp '$tmpfile' '$savefile' && chmod 0644 '$savefile'"
            rm -f "$tmpfile"
        fi
        echo2 "done."
    fi
}

IsOkMirror() {
    local url="$1"
    local docheck=no

    if [ "$detect_all_issues" = "yes" ] ; then
        docheck=yes
    else
        case "$url" in
            https://mirror.jaime.sh/archlinux/lastupdate) docheck=yes ;;
        esac
    fi
    
    if [ "$docheck" = "yes" ] ; then
        Lastsync_lastupdate "$url"
    fi
}

Lastsync_lastupdate() {
    local url="$1"
    local url2=${url/lastupdate/lastsync}
    local lastsync=$(curl --fail -Lsm $download_timeout -w "%{time_total}" "$url2" | head -n1)
    local mirror=""

    if [ "$time_as_datetime" = "yes" ] ; then
        lastsync=$(date --date="@$lastsync" "+%Y%m%d-%H%M%S")
    fi
    if [ "$lastupdate" = "$lastsync" ] ; then
        mirror="${url/lastupdate}"'$repo/os/$arch'
        printf2 "==> Warning: %s skipped due to 'lastupdate' = 'lastsync' (%s)\n" "$mirror" "$lastupdate"
        printf "%-64s %s\n" "$mirror" "lastsync = lastupdate" >> $rank_fails_file
        return 1
    fi
}

AddCountries() {
    # Add countries. The list of names can be separated with commas and/or spaces.
    # If a country name *includes* spaces, then add quotes around it.
    local tail head
    for tail in "$@" ; do
        tail+=","
        while [ -n "$tail" ] ; do
            head=${tail%%,*}
            tail=${tail#$head,}
            [ -n "$head" ] && countries+=("$head")
        done
    done
}

Options() {
    local opts
    local sopts="hp:c:d:n:s:46v"
    local lopts="help,protocol:,country:,download-timeout:,number:,save:,ipv4,ipv6,verbose,issue-detect"

    opts="$(/usr/bin/getopt -o=$sopts --longoptions $lopts --name "$progname" -- "$@")" || {
        Options -h
        return 1
    }

    eval set -- "$opts"

    while true ; do
        case "$1" in
            -p | --protocol)
                protocols+=($(echo "$2" | tr ',' ' '))
                shift
                ;;
            -c | --country)
                AddCountries "$2"
                shift
                ;;
            -d | --download-timeout)
                download_timeout="$2"
                shift
                ;;
            -n | --number)
                max_mirrors_to_show="$2"
                shift
                ;;
            -s | --save)
                savefile="$2"
                shift
                ;;
            -4 | --ipv4) ip_versions+=(4) ;;
            -6 | --ipv6) ip_versions+=(6) ;;

            -v | --verbose)
                verbose=yes; Verbose2 "Handling options ..." ;;
            --epoch)
                time_as_datetime=no ;;
            --issue-detect)
                detect_all_issues=yes ;;           # will be slower, doubles the time!

            -h | --help)
                Usage
                exit 0
                ;;
            
            --) shift ; break ;;
        esac
        shift
    done

    # minimum defaults
    [ ${#protocols[@]} -eq 0 ]     && protocols=("${def_protocols[@]}")
    [ ${#ip_versions[@]} -eq 0 ]   && ip_versions=($def_ip_versions)
    [ -z "$download_timeout" ]     && download_timeout=$def_download_timeout
    [ -z "$max_mirrors_to_show" ]  && max_mirrors_to_show=$def_max_mirrors_to_show
    [ $max_mirrors_to_show -lt 1 ] && max_mirrors_to_show=$def_max_mirrors_to_show

    if [ -n "$1" ] ; then
        AddCountries "$@"
    fi

    if [ ${#countries[@]} -gt 0 ] ; then
        # convert country names (any case!) to country codes (upper case)
        local country_specs="$(LANG=C reflector --list-countries 2>/dev/null | grep -Pv '^-----|^Country ')"
        local country ix=0
        for country in "${countries[@]}" ; do
            case "$country" in
                [A-Z][A-Z]) ;;
                [a-z][a-zA-Z] | [a-zA-Z][a-z])
                    countries[$ix]="$(echo "$country" | tr '[:lower:]' '[:upper:]')"
                    ;;
                *)  countries[$ix]="$(echo "$country_specs" | grep -iw "^$country" | awk '{print $(NF-1)}')"
                    if [ -z "${countries[$ix]}" ] ; then
                        Fatal "unrecognized country '$country' (see 'reflector --list-countries')"
                    fi
                    ;;
            esac
            ((ix++))
        done
    else
        Fatal "give one or more countries"
    fi
}

Fatal() {
    DIE "$1" stay
    Usage
    exit 1
}

Usage() {
    cat <<EOF >&2

Usage: $progname [options] [countries]
Options:
  -c, --country             Rank mirrors from a list of country specs.
                            List items can be separated by commas.
                            A country spec is either 2 letters (country code) or
                            the name of a country.
                            See also the output of command
                               reflector --list-countries
                            Note that a country name including spaces must be quoted.
  -p, --protocol            Supported protocols (https, http). Default: "${def_protocols[@]}"
  -d, --download-timeout    Max time in seconds to rank a mirror. Default: $def_download_timeout
  -n, --number              Max number of the "best" mirrors to show after ranking. Default: $def_max_mirrors_to_show
  -s, --save                Save generated mirrorlist to this file.
  -4, --ipv4                Use IPv4 addresses. Default.
  -6, --ipv6                Use IPv6 addresses.
  -v, --verbose             Show more details about the operation.
      --epoch               Show the time of last update as seconds since the beginning of year 1970.
      --issue-detect        Detect issues of any mirror instead of only mirrors with known problems.
  -h, --help                This help.

Country list can be given also without option -c.

Note: ranking mirrors from many countries will take lots of time.

A configuration file at $conf2 supports the following
settings (i.e. bash variables):

  USER_PREFERRED_MIRRORS    An array of mirrors which will be at the top of the ranking results.
                            If not set or empty, ranking continues without such preference.

Example:
       #!/bin/bash

       USER_PREFERRED_MIRRORS=(
          'https://ftp.acc.umu.se/mirror/archlinux/$repo/os/$arch'
          'https://ftp.halifax.rwth-aachen.de/archlinux/$repo/os/$arch'
       )

EOF
#      --issue-skip          Skip a problematic mirror from ranking results.
}

Main() {
    local progname="$(/usr/bin/basename "$0")"
    local cmdline="$progname $*"
    local conf="$HOME/.config/$progname.conf"
    local conf2='$HOME/.config/$progname.conf'
    local USER_PREFERRED_MIRRORS=()
    local verbose=no
    local time_as_datetime=yes
    local detect_all_issues=no
    local skip_problematic_mirrors=yes

    local protocols=()              # https and/or http
    local countries=()              # list of countries or 'all'
    local ip_versions=()            # 4 or 6
    local download_timeout=""       # for each mirror check
    local max_mirrors_to_show=""
    local savefile=""

    local def_protocols=(https)
    local def_ip_versions=4
    local def_download_timeout=10       # for each mirror check
    local def_max_mirrors_to_show=15

    local fetchcmd

    if [ -x /usr/bin/curl ] ; then
        fetchcmd="curl --fail -Lsm 10 -o-"
    elif [ -x /usr/bin/wget ] ; then
        fetchcmd="wget -O-"
    else
        DIE "neither 'curl' nor 'wget' was found!"
    fi

    if [ -r "$conf" ] ; then
        echo2 "Reading $conf ..."
        source "$conf"
    else
        echo2 "$conf not available, using defaults."
    fi

    Options "$@"

    local rank_fails_file=$(mktemp)

    Rank "$@"

    rm -f $rank_fails_file
}

Main "$@"
