#!/bin/bash

DIE() {
    local msg="$1"
    local code="$2"
    echo "$progname: error: $msg" >&2
    [ "$code" ] || code=1
    Usage $code
    exit 1    # fallback
}

FindFiles() {
    local opt_depth="$1"
    local opt_name="$2"
    local suffix="$3"
    local folder="$4"

    fd $opt_depth $opt_name ".*$suffix" "$folder"
}

SetTimeInterval() {
    local mode="$1"
    local interval="$2"

    case "$mode" in
        h) CheckHour   "$interval"; interval="00/$interval:00:00" ;;
        m) CheckMinSec "$interval"; interval="*:00/$interval:00" ;;
        s) CheckMinSec "$interval"; interval="*:*:00/$interval" ;;
    esac
    sed -i "$timerfile" -e "s|^OnCalendar=.*|OnCalendar=$interval|"
    ReloadTimer
}
CheckHour() {
    if [ -z "$1" ] || [ "$1" -gt 23 ] || [ "$1" -lt 0 ] ; then
        DIE "value for hour ($1) must be 0..23"
    fi
}
CheckMinSec() {
    if [ -z "$1" ] || [ "$1" -gt 59 ] || [ "$1" -lt 0 ] ; then
        DIE "value for $2 ($1) must be 0..59"
    fi
}

ReloadTimer() {
    # echo "$progname: reloading the timer."
    systemctl --user daemon-reload
}

EditTimer() {
    while true ; do
        /bin/emacs --reverse-video "$timerfile"
        TimerIsValid && break
    done
    ReloadTimer
}

TimerIsValid() {
    local oncal=$(grep "OnCalendar=" $HOME/.config/systemd/user/$progname.timer)
    local oncal_orig="$oncal"
    oncal="${oncal##*=}"
    local h="${oncal%%:*}"
    oncal="${oncal#*:}"
    local m="${oncal%%:*}"
    oncal="${oncal#*:}"
    local s="${oncal%%:*}"
    local msg="changed from $omcal_orig to "
    local changed=no

    case "$h" in
        */* | "*" | [0-1][0-9] | 2[0-3]) ;;
        *) h="*"; changed=yes ;;
    esac
    case "$m" in
        */* | "*" | [0-5][0-9]) ;;
        *) m="*"; changed=yes ;;
    esac
    case "$s" in
        */* | "*" | [0-5][0-9]) ;;
        *) s="00"; changed=yes ;;
    esac

    if [ $changed = yes ] ; then
        oncal="OnCalendar=$h:$m:$s"
        echo "==> Info: changed from $oncal_orig to $oncal" >&2
        sed -i "$timerfile" -e "s|^OnCalendar=.*|$oncal|"
    fi
}

ShowTimer() {
    local oncal=$(grep "OnCalendar=" $HOME/.config/systemd/user/$progname.timer)
    oncal=${oncal##*=}
    local h=${oncal%%:*}
    oncal=${oncal#*:}
    local m=${oncal%%:*}
    oncal=${oncal#*:}
    local s=${oncal%%:*}

    if [[ "$h" =~ / ]] ; then
        echo "every ${h#*/} hours"
    elif [[ "$m" =~ / ]] ; then
        echo "every ${m#*/} minutes"
    elif [[ "$s" =~ / ]] ; then
        echo "every ${s#*/} seconds"
    else
        echo "$h:$m:$s"
    fi
}

ShowStatus() { RunInTerminal "systemctl --user status $progname.timer"; }

SetupUserService() {
    local -r srvdir="$HOME/.config/systemd/user"
    local -r skeldir="/etc/skel/$progname"
    local -r timer="$srvdir/$progname.timer"

    if [ ! -f "$timer" ] ; then
        echo "==> Info: enabling service timer $timer" >&2 
        mkdir -p "$srvdir"
        cp "$skeldir/$progname".{service,timer}  "$srvdir"
        systemctl --user enable "$progname".timer
        systemctl --user start  "$progname".timer
        systemctl --user daemon-reload
    fi
}

Usage() {
    # -t, --timer           Configures the time to wait before showing the next picture.
    #                       The value is an integer with one of suffixes
    #                           h  (hours)
    #                           m  (minutes)
    #                           s  (seconds)
    #                       or an 'OnCalendar' value described in 'man systemd.time'.

    cat <<EOF >&2
Usage:     $progname [options]
Options:
           -h, --help            This help.
           -e, --edit            (Advanced) Edit the timer service definition file.
                                 See also: 'man systemd.time'.
           -i, --show-interval   Show the currently configured value of the time interval
                                 between wallpaper changes.
           -r, --reload          Reload the services, including this timer.
           --status              Show the status of the related systemd timer.
           --th *                Set the time interval to * hours.
           --tm *                Set the time interval to * minutes.
           --ts *                Set the time interval to * seconds.
Configuration
           If file $myconf2 exists, it will be read.
           Otherwise file $commonconf will be read.

           They are bash files, and the supported settings are:
           SUPPORTED_FOLDERS       An array of absolute folder paths.
                                   Default: (${SUPPORTED_FOLDERS[*]})
           SUPPORTED_SUFFIXES      An array of file name endings as strings.
                                   Default: (${SUPPORTED_SUFFIXES[*]})
                                   Note: a string can be longer than just e.g. "jpg".
           RECURSE_SUFFIXES        "yes" or "no". Default: "$RECURSE_SUBFOLDERS"
           SEARCH_CASE_SENSITIVE   "yes" or "no". Default: "$SEARCH_CASE_SENSITIVE"
Examples:
           \$ $progname --tm 10    # sets the interval to 10 minutes
           \$ $progname -i
                every 10 minutes
EOF
    
    [ "$1" ] && exit $1
}

DumpOptions() {
    if [ "$LOPTS" ] ; then
        LOPTS=${LOPTS//:/}          # remove all : chars
        LOPTS="--${LOPTS//,/ --}"   # make all words as options with prefix "--"
    fi
    if [ "$SOPTS" ] ; then
        SOPTS=${SOPTS//:/}          # remove all : chars
        SOPTS=${SOPTS//?/ -&}       # make all letters as options with prefix "-"
        SOPTS=${SOPTS:1}            # remove the first space
    fi
    [ "$LOPTS$SOPTS" ] && echo $SOPTS $LOPTS
}

Options() {
    local opts
    opts="$(/bin/getopt -a -o=$SOPTS --longoptions $LOPTS --name "$progname" -- "$@")" || DIE "getopt error"
    eval set -- "$opts"

    while true ; do
        case "$1" in
            --) shift; break ;;
            -h | --help)           Usage 0 ;;
            --dump-options)        DumpOptions;                 exit 0 ;;
            -e | --edit)           EditTimer;                   exit 0 ;;
            -r | --reload)         ReloadTimer;                 exit 0 ;;
            -i | --show-interval)  ShowTimer;                   exit 0 ;;
            --status)              ShowStatus;                  exit 0 ;;
            --th | --tm | --ts)    SetTimeInterval ${1:3} "$2"; exit 0 ;;
        esac
        shift
    done
}

Main() {
    local progname="wallpaper-changer"    # don't use: local progname="$(basename "$0")"
    local -r myconf="$HOME/.config/$progname.conf"
    local -r myconf2='~'/.config/"$progname".conf
    local -r commonconf="/etc/$progname.conf"

    local SUPPORTED_FOLDERS=(/usr/share/endeavouros/backgrounds)
    local SUPPORTED_SUFFIXES=(jpg png)
    local RECURSE_SUBFOLDERS="no"
    local SEARCH_CASE_SENSITIVE="no"
    local -r timerfile="$HOME/.config/systemd/user/$progname.timer"

    local LOPTS="dump-options,edit,help,reload,show-interval,status,th:,tm:,ts:"
    local SOPTS="ehir"

    SetupUserService
    Options "$@"

    local log="/tmp/$progname.log"

    if [ -e "$myconf" ] ; then
        source "$myconf" || return 1
    else
        source "$commonconf" || return 1
    fi

    local opt_name=""
    local opt_depth="--maxdepth 1"
    [ "$SEARCH_CASE_SENSITIVE" = "yes" ] && opt_name="--case-sensitive"
    [ "$RECURSE_SUBFOLDERS"    = "yes" ] && opt_depth=""

    local folder suffix
    local filelist=() tmp=()

    for folder in "${SUPPORTED_FOLDERS[@]}" ; do
        for suffix in "${SUPPORTED_SUFFIXES[@]}" ; do
            readarray -t tmp <<< $(FindFiles "$opt_depth" "$opt_name" "$suffix" "$folder")
            [ ${#tmp[@]} -gt 0 ] && filelist+=("${tmp[@]}")
        done
    done

    local count=${#filelist[@]}

    if [ $count -gt 0 ] ; then
        local nr=$(shuf -i 0-$((count-1)) -n1)
        local file="${filelist[$nr]}"            # $(echo "$filelist" | sed -n "${nr}p")
        if [ -r "$file" ] ; then
            echo "$(date +%Y%m%d-%H%M): $file" >> $log
            eos-wallpaper-set "$file"
        else
            DIE "wallpaper file '$file' not readable"
        fi
    else
        DIE "no wallpapers found."
    fi
}

Main "$@"
