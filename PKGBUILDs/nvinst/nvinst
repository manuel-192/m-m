#!/bin/bash

echo2()   { echo -e "$@" >&2; }
printf2() { printf  "$@" >&2; }
MULTILINE_MSG() {
    local -r msgtype="$1"
    local -r head="$progname: $msgtype:"
    local -r headempty="${head//?/ }"
    local line
    eos-color "$msgtype" 2
    echo2 "$head $2"
    shift 2
    for line in "$@" ; do
        echo2 "$headempty $line"
    done
    eos-color reset 2
}
INFO()    { MULTILINE_MSG info    "$@"; }
WARN()    { MULTILINE_MSG warning "$@"; }
DIE()     { MULTILINE_MSG error   "$@"; exit 1; }
DIEHELP() { MULTILINE_MSG error   "$@"; Help; exit 1; }
ASSERT()  { "$@" || DIE "'$*' failed."; }

HasPkgInRepo()       { /bin/pacman -Ssq "$1" &>/dev/null; }
HasRepo()            { /bin/pacman-conf --repo-list | grep "^$1$" >/dev/null; }
CheckRepo_multilib() {
    if [ $use32 = yes ] && ! HasRepo multilib ; then
        WARN "Repository [multilib] is not enabled in /etc/pacman.conf." \
             "It is needed e.g. for gaming." \
             "Consider enabling [multilib] or use option --no32 to hide this warning."
        use32=no
    fi
}

DetectDrivers() { # echo one or more driver names; return 0=Nvidia GPU found, 1=Nvidia GPU not found
    local families family pkgnames=() fnames=() 
    families="$(lspci -d "$NVIDIA"::03xx | sed -E 's|.* NVIDIA Corporation ([^ ]+) .*|\1|')"
    for family in $families ; do
        case "$family" in
            "")                   continue ;;                           # Nvidia GPU not detected.
            TU*|GA*|AD*|GB*|GN*)  pkgnames+=(nvidia-open-dkms) ;;       # Nvidia's open source driver, Turing and newer.
            GM*|GP*|GV*)          pkgnames+=("$pkgname_aur") ;;         # For Maxwell,Pascal,Volta.
            *)                    pkgnames+=(nouveau) ;;                # For older Nvidia GPUs.
        esac
        case "$family" in
            TU*)  fnames+=("$family (Turing)") ;;
            GA*)  fnames+=("$family (Ampere)") ;;
            AD*)  fnames+=("$family (Ada Lovelace)") ;;
            GB*)  fnames+=("$family (Blackwell)") ;;
            GN*)  fnames+=("$family ([not recognized])") ;;
            GM*)  fnames+=("$family (Maxwell)") ;;
            GP*)  fnames+=("$family (Pascal)") ;;
            GV*)  fnames+=("$family (Volta)") ;;
            *)    fnames+=("$family ([before Maxwell])") ;;
        esac
    done
    if [ "${pkgnames[0]}" ] ; then
        local ix
        for ((ix=0; ix < ${#pkgnames[@]}; ix++)) ; do
            echo "${pkgnames[$ix]}"
            INFO "Detected GPU: ${fnames[$ix]}"
        done
    fi
}

GetScenario() {
    local detected=("${detected_drivers[@]}")
    case "${#detected[@]}" in
        0)  WARN "Nvidia GPU not detected."; exit 0 ;;
        1)  scenario="${detected[0]}" ;;
        *)  # Multiple different Nvidia GPUs detected!
            local fzf=(fzf --multi --header="::: Find one driver with arrows; ENTER accepts. (Multiple Nvidia GPUs: TAB selects)")
            scenario=$(printf "%s\n" "${detected[@]}" | sort -u | "${fzf[@]}")
            [ "$scenario" ] || exit 0
            ;;
    esac
}
FillInstallsAndCommands() {
    local scen extra pkgs="${BASE_PACKAGES_FOR_SCENARIOS[common]}"
    install_pkgs+=($pkgs)
    for scen in $scenario ; do
        pkgs="${BASE_PACKAGES_FOR_SCENARIOS[$scen]}"
        [ "$pkgs" ] && install_pkgs+=($pkgs)
    done
    for extra in $scenario_extras ; do
        case "$extra" in
            no32)       use32=no ;;
            prime)      useprime=yes ;;
            switcheroo) useswitcheroo=yes ;;
            test)       dryrun=yes ;;
        esac
    done

    if [ $use32 = yes ] ; then
        for scen in $scenario ; do
            pkgs="${BASE_PACKAGES_FOR_SCENARIOS_32[$scen]}"
            [ "$pkgs" ] && install_pkgs+=($pkgs)
        done
    fi
    if [ $useprime = yes ] ; then
        install_pkgs+=(${BASE_PACKAGES_FOR_SCENARIO_EXTRAS[prime]})
    fi
    if [ $useswitcheroo = yes ] ; then
        install_pkgs+=(${BASE_PACKAGES_FOR_SCENARIO_EXTRAS[switcheroo]})
    fi

    install_pkgs=($(printf "%s\n" "${install_pkgs[@]}" | sort -u))

    [ $useswitcheroo = yes ] && commands+=("sudo systemctl enable --now switcheroo-control.service")
}
FillRemoves() {
    local all_nvidia_pkgs=(
        ${BASE_PACKAGES_FOR_SCENARIOS[@]}
        ${BASE_PACKAGES_FOR_SCENARIO_EXTRAS[@]}
        ${BASE_PACKAGES_FOR_SCENARIOS_32[@]}
    )
    all_nvidia_pkgs=($(printf "%s\n" "${all_nvidia_pkgs[@]}" | sort -u))

    local wanted maybe_remove=() will_remove=()
    for wanted in "${all_nvidia_pkgs[@]}" ; do
        printf "%s\n" "${all_installed_pkgs[@]}" | grep "^$wanted$" >/dev/null && maybe_remove+=("$wanted")
    done
    for wanted in "${maybe_remove[@]}" ; do
        printf "%s\n" "${install_pkgs[@]}" | grep "^$wanted$" >/dev/null || will_remove+=("$wanted")
    done
    remove_pkgs="$(printf "%s\n" "${will_remove[@]}")"
}
CleanupInstalls() {
    local wanted will_install=()
    for wanted in "${install_pkgs[@]}" ; do
        printf "%s\n" "${all_installed_pkgs[@]}" | grep "^$wanted$" >/dev/null || will_install+=("$wanted")
    done
    install_pkgs=("${will_install[@]}")
}

Main() {
    local progname=${0##*/}
    local LOPTS="help,test,no32,prime,switcheroo,nvidia,580xx::,nouveau,vulkan-nouveau,list-opts,list-fallbacks"
    local SOPTS="ht"
    local -r pkgname_aur=nvidia-580xx-dkms
    local fallback_for_aur=vulkan-nouveau

    local HW_DETECTED=(       # empty means no Nvidia GPU detected
        nvidia-open-dkms
        "$pkgname_aur"
        nouveau               # both nouveau and vulkan-nouveau
    )
    local SCENARIOS=(         # use values as indexes below
        # bumblebee
        # conf
        nvidia-open-dkms      # only dkms supported
        "$pkgname_aur"
        nouveau               # there's no such package to install ...
        vulkan-nouveau
    )
    local SCENARIO_EXTRAS=(
        no32                  # --no32
        prime                 # --prime
        switcheroo            # --switcheroo
        "test"                # --test
    )
    declare -A BASE_PACKAGES_FOR_SCENARIOS=(
        [nouveau]=""
        [vulkan-nouveau]="vulkan-nouveau"
        [nvidia-open-dkms]=" nvidia-open-dkms  nvidia-settings       opencl-nvidia"
        [$pkgname_aur]="$pkgname_aur nvidia-580xx-settings opencl-nvidia-580xx"
        [common]="linux-firmware-nvidia"
    )
    declare -A BASE_PACKAGES_FOR_SCENARIO_EXTRAS=(
        [prime]="nvidia-prime"
        [switcheroo]="switcheroo-control"
    )
    declare -A BASE_PACKAGES_FOR_SCENARIOS_32=(
        [nouveau]=""
        [vulkan-nouveau]="lib32-vulkan-nouveau"
        [nvidia-open-dkms]="lib32-libvdpau lib32-nvidia-utils lib32-opencl-nvidia"
        [$pkgname_aur]="lib32-nvidia-580xx-utils lib32-opencl-nvidia-580xx"
    )
    local scenario="" scenario_extras=""
    local use32=yes useprime=no useswitcheroo=no       # for --no32 --prime --switcheroo
    local dryrun=no                                    # for --test
    local install_pkgs=()
    local remove_pkgs
    local commands=()
    local has_580x_in_repo=no
    local detected_drivers=""

    Options "$@"

    CheckRepo_multilib

    detected_drivers=($(DetectDrivers))

    [ "$scenario" ] || GetScenario
    if [ "$scenario" = $pkgname_aur ] ; then
        HasPkgInRepo $pkgname_aur && has_580x_in_repo=yes
        if [ $has_580x_in_repo = no ] ; then
            # User wanted AUR packages. We don't support that directly, but provide indirect help.
            dryrun=yes
            scenario=$fallback_for_aur
            WARN "The recommended driver $pkgname_aur is in the AUR." "Use 'yay -S $pkgname_aur' to install it." "Using $scenario as fallback."
        fi
    fi
    INFO "Driver: $scenario"

    local all_installed_pkgs=()
    readarray -t all_installed_pkgs <<< "$(/bin/pacman -Qsq nvidia)"  # nvidia-related packages         # readarray -t all_installed_pkgs <<< "$(/bin/pacman -Qq)"

    # Find which to remove and which to install. Order here is important!
    FillInstallsAndCommands
    FillRemoves
    CleanupInstalls

    # Fill the install and remove command lines.
    local cmd_install cmd_remove has_work=no
    [ "${install_pkgs[0]}" ] && cmd_install=(sudo pacman -Syu --needed ${install_pkgs[*]})
    [ "$remove_pkgs" ]       && cmd_remove=(sudo pacman -Rs $remove_pkgs)

    # Run the commands if not dryrun. Show what is happening.

    [ "$cmd_remove$cmd_install$commands" ] && has_work=yes

    if [ "$has_work" = yes ] ; then
        echo2 "\n###################### COMMANDS TO RUN ######################"
        Show "${cmd_remove[@]}"
        Show "${cmd_install[@]}"
        Show "${commands[@]}"
        echo2 "#############################################################\n"
        Run "${cmd_remove[@]}"
        Run "${cmd_install[@]}"
        Run "${commands[@]}"
    else
        echo2 ""
        INFO "Nothing to do!"
    fi
}

Show() {
    if [ "$1" ] ; then
        echo2 "$@"
    fi
}
Run() {
    if [ "$1" ] && [ "$dryrun" = no ] ; then
        echo2 "Running: $*"
        "$@"
    fi
}

Options() {
    local opts
    opts="$(/bin/getopt -o="$SOPTS" --longoptions "$LOPTS" --name "$progname" -- "$@")" || DIEHELP "Argument handling failed."
    eval set -- "$opts"
    while true ; do
        case "$1" in
            --            )   shift; break ;;
            --help  | -h  )   Help 0 ;;

            --test  | -t  )   dryrun=yes ;;
            --no32        )   use32=no ;;
            --prime       )   useprime=yes ;;
            --switcheroo  )   useswitcheroo=yes ;;

            --nvidia)         scenario=nvidia-open-dkms ;;
            --580xx)          scenario=$pkgname_aur; fallback_for_aur="$2"; shift ;;
            #--580xx-fallback) fallback_for_aur="$2"; shift ;;
            --nouveau)        scenario=nouveau ;;
            --vulkan-nouveau) scenario=vulkan-nouveau ;;

            --list-fallbacks) echo "nouveau vulkan-nouveau"; exit 0 ;;
            --list-opts)      SOPTS=${SOPTS//:/}
                              LOPTS=${LOPTS//:/}
                              echo "${SOPTS//?/-& }--${LOPTS//,/ --}"   # 'patsub_replacement' shopt needed
                              exit 0
                              ;;

        esac
        shift
    done
    [ "$1" ] && DIEHELP "Unsupported parameter '$1'"
}
Help() {
    eos-color tip 2
    cat <<EOF >&2
Purpose: Manage Nvidia GPU drivers based on given options.
         Without options the recommended driver will be installed.
         Unnecessary alternative GPU driver packages may be uninstalled first.
Syntax:  $progname [options]
Options: --help, -h           This help.
         --test, -t           Run in test mode, don't make any changes.
         --nvidia             Install nvidia-open-dkms (for Turing and newer).
         --nouveau            Use the open source kernel driver 'nouveau' (for older than Maxwell).
         --vulkan-nouveau     Install vulkan-nouveau (for older than Maxwell).
         --580xx[=F]          Install $pkgname_aur (for Maxwell, Pascal, and Volta).
                              Assumes $pkgname_aur exists in repositories.
                              Optional F (nouveau or vulkan-nouveau) is the fallback
                              if $pkgname_aur is not in repositories.
                              Default fallback is vulkan-nouveau.
         --no32               Don't install 32-bit packages. Note: gaming needs them.
         --prime              Install also prime render offload support.
         --switcheroo         Install switcheroo-control and enable its service.
Notes:   * For gaming purposes, repository [multilib] should be enabled in /etc/pacman.conf.
         * Maxwell/Pascal/Volta GPUs can use one of: nvidia-580xx-dkms/nouveau/vulkan-nouveau.
         * Certain packages related to the driver will be installed too.
Examples:
    $progname --test            # Runs in testing mode and shows what would be done.
    $progname                   # Detects the driver and installs it; also uninstalls unnecessary alternatives if found.
    $progname --580xx=nouveau   # Chooses nvidia-580xx-dkms to be installed if possible, fallback is nouveau.
    $progname --nvidia          # Chooses nvidia-open-dkms to be installed.
           
EOF
    eos-color reset 2
    [ "$1" ] && exit "$1"
}

Main "$@"
