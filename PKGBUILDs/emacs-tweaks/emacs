#!/bin/bash

# Run emacs by
#  - adjusting window size
#  - using dark colors
#  - new option --bash='file' creates a template bash script

Main() {
    local progname=${0##*/}
    local args=()
    local template=""

    HandleOptions "$@"
    local emacs_parameters=(--reverse-video
                            --no-splash
                            --geometry=$(Geometry)
                            "${args[@]}"
                           )
    /bin/emacs "${emacs_parameters[@]}" &>/dev/null &
}

HandleOptions() {
    while [ "$1" ] ; do
        case "$1" in
            -? | --tip)
                cat <<EOF >&2
Usage:
                $progname [new-options] [parameters]
New options:
                --bash=X         Create an executable bash script file X using a hard-coded or user-given template.
                --template=Y     User-given template file Y for option --bash.

Otherwise normal emacs parameters are OK.
EOF
                exit 0
                ;;
            --template=*) template="${1#*=}" ;;
            --template)   template="$2"; shift ;;
            --bash=*) CreateBashFile "${1#*=}" "$template"; args+=("${1#*=}") ;;
            --bash)   CreateBashFile "$2" "$template";      args+=("$2");     shift ;;
            *) args+=("$1") ;;
        esac
        shift
    done
}

Geometry() {
    local xrandr=$(xrandr | head -n1 | sed -e 's|.* current ||' -e 's|, maximum.*||' -e 's| x | |')  # 3840 2160
    local width=$( echo $xrandr | awk '{print $1}')
    local height=$(echo $xrandr | awk '{print $2}')
    local wanted_columns
    local wanted_rows

    case "$width" in
        3840) wanted_columns=150 ;;
        1920) wanted_columns=100 ;;
    esac
    case "$height" in
        2160) wanted_rows=60 ;;
        1080) wanted_rows=40 ;;
    esac

    # echo "${wanted_columns}x${wanted_rows}" >&2
    echo "${wanted_columns}x${wanted_rows}"
}

CreateBashFile() {
    local file="$1"
    local template="$2"

    case "$template" in
        "")
            cat <<EOF > "$file"
#!/bin/bash

echo2()   { echo -e "\$@" >&2; }
printf2() { printf  "\$@" >&2; }
MSG()     { echo2 "==> \$progname: \$1: \$2"; }
INFO()    { MSG info    "\$1"; }
WARN()    { MSG warning "\$1"; }
DIE()     { MSG error   "\$1"; exit 1; }
ASSERT()  { "\$@" || DIE "'\$*' failed."

Options() {
    local opts
    opts="\$(/bin/getopt -o="\$OPTS" --longoptions "\$LOPTS" --name "\$progname" -- "\$@")" || DIE "\$FUNCNAME failed."
    eval set -- "\$opts"
    while true ; do
        case "\$1" in
            --) shift; break ;;
            -h | --help) Help 0 ;;
            # add your options here
        esac
        shift
    done
}
Help() {
    # fill in missing parts (??)
    echo2 "Purpose: ??"
    echo2 "Syntax:  \$progname ??"
    echo2 "Options: ??"
    # explain your options here

    [ "\$1" ] && exit \$1
}
Main() {
    local progname=\${0##*/}
    local LOPTS="help"
    local SOPTS="h"

    Options "\$@"
}
Main "\$@"
EOF
            ;;
        *)
            if [ -r "$template" ] ; then
                cp "$template" "$file"
            else
                echo "==> $progname: error: template file '$template' is not readable." >&2
                return 1
            fi
            ;;
    esac
    chmod +x "$file"
}

Main "$@"

