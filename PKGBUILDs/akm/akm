#!/bin/bash
#
# AKM = Arch Kernel Manager with a GUI.

echo2() { echo "$@" >&2 ; }
debug() {
    test $DEBUGGING -eq 1 && echo2 "$@"
}


eos_yad() {
    GDK_BACKEND=x11 /usr/bin/yad "$@"
}
eos_yad_terminal() {
    # Show a terminal that is capable of supporting option -e properly. Empty if not found.
    # Requires: yad
    #
    # These terminal programs are known not to work with this program:
    #     qterminal
    #     kitty
    # The following terminals are known to work:
    local suitable_terminals="xfce4-terminal konsole gnome-terminal mate-terminal lxterminal terminator tilix termite xterm"
    local eos_terminal_prog=""
    local xx

    for xx in $suitable_terminals ; do
        if [ -x "/usr/bin/$xx" ] ; then
            eos_terminal_prog="/usr/bin/$xx"
            echo "$eos_terminal_prog"
            return 0
        fi
    done

    printf "%s\n    %s\n%s" \
           "Sorry, none of the terminal programs:" \
           "$suitable_terminals" \
           "is installed. Some features may not work as expected." \
        | eos_yad --text-info \
                  --title="Warning" --height=200 --width=700 --wrap --button=yad-ok:0
    return 1
}
eos_yad_RunCmdTermBash() {
    local cmd="$1"
    local prompt="$2"

    local term="$(eos_yad_terminal)"
    test -n "$term" || return 1

    local tmpfile=$(mktemp)

    echo "#!/bin/bash"                                   >> $tmpfile
    echo "$cmd"                                          >> $tmpfile
    echo "read -p 'Press ENTER to close this window: '"  >> $tmpfile

    chmod +x $tmpfile
    if [ -n "$prompt" ] ; then
        $term -e "bash -c \"echo $prompt ; $tmpfile ; rm -f $tmpfile\""
    else
        $term -e "bash -c \"$tmpfile ; rm -f $tmpfile\""
    fi
}

IsInstalled()   { pacman -Q "$1" >& /dev/null && echo true || echo false ; }

PkgVersion()    { pacman -Q "$1" 2>/dev/null | awk '{print $2}' ; }
ArchVersion() {
    local pkg="$1"
    local repo

    case "$pkg" in
        linux | linux-headers | linux-lts*) repo=core ;;
        linux-zen* | linux-hardened*)       repo=extra ;;
    esac
    if [ "$uses_testing_repo" = "yes" ] ; then
        if [ -n "$(pacman -Si testing/"$pkg" 2>/dev/null)" ] ; then
            repo=testing
        fi
    fi
    LANG=C pacman -Si $repo/"$pkg" | grep ^Version | awk '{print $3}'
}

NewValue() { echo "$result" | cut -d '|' -f $ix | tr [:upper:] [:lower:] ; }

KernelOrgVersion() {
    case "$1" in
        linux)
            local stable="$(echo $(  grep -A2 stable:   $tmpfile | head -n 2 | grep strong | sed 's|<[^0-9]*>||g'))"
            local mainline="$(echo $(grep -A2 mainline: $tmpfile | head -n 2 | grep strong | sed -e 's|^.*<strong>||' -e 's|</strong>.*$||' | grep -v rc))"
            if [ -n "$mainline" ] ; then
                echo "$mainline"
            else
                echo "$stable"
            fi
            ;;
        linux-lts) echo $(grep -A2 longterm: $tmpfile | head -n 2 | grep strong | sed 's|<[^0-9]*>||g') ;;
        *) echo "$na" ;;
    esac
}

Main() {
    local DEBUGGING=0
    local install=() remove=()
    declare -A Downgrade OldVersion NewVersion OldKernel OldHeader NewKernel NewHeader ArchVersion
    local pkg
    local pkgs="linux linux-lts linux-zen linux-hardened"
    local dkms=$(test -n "$(PkgVersion dkms)" && echo true || echo false)
    local cmd result
    local xx ix
    local missing_headers=()
    local columns=6                                 # 4 = all features included. TODO: check value!!
    local downgrade_supported=0
    local na="--"
    local same="="
    local uses_testing_repo=$(test -n "$(grep "^\[testing\]" /etc/pacman.conf)" && echo yes || echo no)

    local tmpfile=$(mktemp)
    wget -q -O $tmpfile https://www.kernel.org/index.html   # for KernelOrgVersion

    for pkg in $pkgs ; do
        xx="$(PkgVersion "$pkg")"
        OldVersion["$pkg"]="$xx"
        OldKernel["$pkg"]=$(test -n "$xx" && echo true || echo false)
        xx="$(PkgVersion "$pkg"-headers)"
        OldHeader["$pkg"]=$(test -n "$xx" && echo true || echo false)
        xx="$(KernelOrgVersion "$pkg")"
        NewVersion["$pkg"]="$xx"
        xx="$(ArchVersion "$pkg")"
        ArchVersion["$pkg"]="$xx"
    done
    rm -f $tmpfile

    cmd=(yad --form --title="Simple kernel manager")

    if [ $downgrade_supported -eq 0 ] ; then
        ((columns--))
    fi
    cmd+=(--columns=$columns)

    ### SHOW OLD VALUES

    # Kernels
    cmd+=(--field="<b>Kernel</b>:LBL" "")
    for pkg in $pkgs ; do
        cmd+=(--field="$pkg":chk ${OldKernel["$pkg"]})
    done

    # Headers
    cmd+=(--field="<b>Headers</b>:LBL" "")
    for pkg in $pkgs ; do
        cmd+=(--field="${pkg}-headers":chk ${OldHeader["$pkg"]})
    done

    # Current versions
    cmd+=(--field="<b>Installed</b>:LBL" "")
    for pkg in $pkgs ; do
        xx="${OldVersion[$pkg]}"
        test -n "$xx" || xx="$na"
        cmd+=(--field="$xx":LBL "")
    done

    # Latest available versions at repos
    cmd+=(--field="<b>Arch</b>:LBL" "")
    for pkg in $pkgs ; do
        xx="${ArchVersion[$pkg]}"
        case "$xx" in
            "${OldVersion[$pkg]}") xx="$same" ;;
            "") xx="$na" ;;
        esac
        cmd+=(--field="$xx":LBL "")
    done

    # Latest available versions at kernel.org
    cmd+=(--field="<b>Kernel.org</b>:LBL" "")
    for pkg in $pkgs ; do
        xx="${NewVersion[$pkg]}"
        test -n "$xx" || xx="$na"
        cmd+=(--field="$xx":LBL "")
    done

    if [ $downgrade_supported -eq 1 ] ; then
        # Downgrades
        cmd+=(--field="<b>Downgrade</b>:LBL" "")
        for pkg in $pkgs ; do
            cmd+=(--field="":chk false)
        done
    fi

    ### GET NEW VALUES

    result=$("${cmd[@]}")
    test -n "$result" || return 1

    debug "$result"

    # Kernels
    ix=1                    # skip column header
    for pkg in $pkgs ; do
        ((ix++))
        xx="$(NewValue)"
        #debug "$pkg : $xx"
        NewKernel["$pkg"]="$xx"
    done

    # Headers
    ((ix++))                # skip column header
    for pkg in $pkgs ; do
        ((ix++))
        xx="$(NewValue)"
        #debug "${pkg}-headers : $xx"
        NewHeader["$pkg"]="$xx"
    done

    # Current versions (read-only values)
    ((ix++))
    for pkg in $pkgs ; do
        ((ix++))
    done

    # Latest versions (read-only values)
    ((ix++))
    for pkg in $pkgs ; do
        ((ix++))
    done

    if [ $downgrade_supported -eq 1 ] ; then
        # Downgrades
        ((ix++))                # skip column header
        for pkg in $pkgs ; do
            ((ix++))
            xx="$(NewValue)"
            #debug "downgrade $pkg : $xx"
            Downgrade["$pkg"]="$xx"
        done
    fi

    ### CHECK IF "FIXING" VARIABLES IS NEEDED

    for pkg in $pkgs ; do
        if [ "$dkms" = "true" ] ; then
            if [ "${NewKernel[$pkg]}" = "true" ] ; then
                if [ "${NewHeader[$pkg]}" = "false" ] ; then
                    missing_headers+=("$pkg"-headers)
                fi
            fi
        fi
    done
    if [ -n "$missing_headers" ] ; then
        echo "${missing_headers[*]}" | \
            yad --text-info --width=400 --wrap --title="Kernel headers recommended with dkms" \
                --button=yad-no:1 --button=yad-yes:0 \
            && {
            for pkg in "${missing_headers[@]}" ; do
                xx="${pkg%-headers}"
                NewHeader["$xx"]=true                 # headers probably are needed with dkms
            done
        }
    fi

    ### SHOW "NEW" VALUES AFTER ASKING THEM

    if [ $DEBUGGING -eq 1 ] ; then
        echo -n "kernels     :" ; for pkg in $pkgs ; do echo -n " ${NewKernel[$pkg]}" ; done ; echo ""
        echo -n "headers     :" ; for pkg in $pkgs ; do echo -n " ${NewHeader[$pkg]}" ; done ; echo ""
        echo -n "versions    :" ; for pkg in $pkgs ; do echo -n " ${OldVersion[$pkg]}" ; done ; echo ""
        if [ $downgrade_supported -eq 1 ] ; then
            echo -n "downgrades  :" ; for pkg in $pkgs ; do echo -n " ${Downgrade[$pkg]}" ; done ; echo ""
        fi
    fi

    # Now we have arrays: OldKernel OldHeader NewKernel NewHeader.
    # Build install and remove commands.

    for pkg in $pkgs ; do
        if [ "${NewKernel[$pkg]}" = "true" ] ; then
            test "${OldKernel[$pkg]}" = "false" && install+=("$pkg")
        else
            test "${OldKernel[$pkg]}" = "true" && remove+=("$pkg")
        fi
        if [ "${NewHeader[$pkg]}" = "true" ] ; then
            test "${OldHeader[$pkg]}" = "false" && install+=("$pkg"-headers)
        else
            test "${OldHeader[$pkg]}" = "true" && remove+=("$pkg"-headers)
        fi
    done

    debug "remove:  ${remove[*]}"
    debug "install: ${install[*]}"

    cmd=()
    if [ -n "$install" ] ; then
        cmd+=(pacman -S)
        for pkg in "${install[@]}" ; do
            cmd+=("$pkg")
        done
        test -n "$remove" && cmd+=(";")
    fi
    if [ -n "$remove" ] ; then
        cmd+=(pacman -Rsn)
        for pkg in "${remove[@]}" ; do
            cmd+=("$pkg")
        done
    fi

    if [ -n "$cmd" ] ; then
        echo "${cmd[@]}"
        eos_yad_RunCmdTermBash "echo '${cmd[*]}' ; su -c \"${cmd[*]}\""
    fi
}

Main
