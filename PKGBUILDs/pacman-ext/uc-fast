#!/bin/bash

# Arch and EndeavourOS update checks using mainly lastupdate and state files.
# Assumption: the lastupdate file is NOT abused by making it equal to lastsync.
# Exit code is similar to 'checkupdates'.

Operate() {
    opts=$(/bin/getopt -o=$sopts --longoptions=$lopts --name $progname -- "$@") || Usage $EXIT_ERROR
    eval set -- "$opts"
    while true ; do
        case "$1" in
            -a | --arch)
                op="-a"
                os=Arch
                ml=mirrorlist
                file=lastupdate
                MainNext $op
                ret_arch=$?
                ;;
            -e | --endeavouros)
                op="-e"
                os=EndeavourOS
                ml=endeavouros-mirrorlist
                file=state
                MainNext $op
                ret_eos=$?
                ;;
            -y | --aur)
                op="-y"
                ShowResult "yay -Qua" "-"
                if yay -Qua >/dev/null ; then
                    ret_aur=$EXIT_UPDATES_YES
                    Verbose "AUR updates available.\n"
                else
                    Verbose "No AUR updates.\n"
                fi
                ;;
            -h | --help) Usage $EXIT_UPDATES_NO ;;
            --verbose) ;;                             # already handled
            --reset-history | -r) ;;                  # already handled
            --) break ;;
            *) Usage $EXIT_ERROR ;;
        esac
        shift
    done
    [ "$op" ] || DIE "operation(s) missing"
}

Main() {
    local progname=${0##*/}
    local os
    local ml
    local file
    local verbose=0
    local reset_history=no
    local op=""
    local -r EXIT_UPDATES_YES=0
    local -r EXIT_ERROR=1
    local -r EXIT_UPDATES_NO=2
    local ret_arch=$EXIT_UPDATES_NO
    local ret_eos=$EXIT_UPDATES_NO
    local ret_aur=$EXIT_UPDATES_NO
    # local -r right_after_boot_file=/tmp/$progname.tmp

    [ "$1" ] || Usage $EXIT_ERROR

    # Better handle option --verbose before other options.
    # Option --verbose can be given more than once to give more info (but max 2 times for any effect).
    for arg in "$@" ; do
        case "$arg" in
            --verbose) ((verbose++)) ;;
            --reset-history | -r) reset_history=yes ;;
        esac
    done

    local lopts=verbose,arch,endeavouros,aur,help,reset-history
    local sopts=aeyhr
    local opts
    local out=""

    Operate "$@"
    echo "$out" | column -t -s'|'

    if [ $ret_arch -eq $EXIT_UPDATES_YES ] || [ $ret_eos -eq $EXIT_UPDATES_YES ] || [ $ret_aur -eq $EXIT_UPDATES_YES ]
    then
        return $EXIT_UPDATES_YES
    else
        return $EXIT_UPDATES_NO
    fi
}

Usage() {
    cat <<EOF >&2
Usage: $progname [options] {operations}
Options:
    -h, --help           This help.
    --verbose            More verbose output.
Operations:
    -a, --arch           Check Arch package updates.
    -e, --endeavouros    Check EndeavourOS package updates.
    -y, --aur            Check AUR package updates.

EOF
    [ "$1" ] && exit "$1"
}

GetUrlFromMirrorsFile() {
    url=$(grep -m1 "^Server = " /etc/pacman.d/$ml)
    [ "$url" ] || DIE "/etc/pacman.d/$ml has no mirrors configured!"
    url=${url#*= }
}

DiscoverUrl() {
    [ -r /etc/$progname.conf ] && source /etc/$progname.conf &>/dev/null
    case "$os" in
        EndeavourOS)
            if [ "$EOS_MIRROR" ] ; then
                url="$EOS_MIRROR"
            else
                GetUrlFromMirrorsFile
                url=${url%\$repo/\$arch}$file
            fi
            ;;
        Arch)
            if [ "$ARCH_MIRROR" ] ; then
                url="$ARCH_MIRROR"
            else
                GetUrlFromMirrorsFile
                url=${url%\$repo/os/\$arch}$file
            fi
            ;;
    esac
}

MainNext() {
    declare -A renamedos=(
        [EndeavourOS]=x
        [Arch]=y
    )
    declare -A renamedfile=(
        [state]=X
        [lastupdate]=X
    )
    local -r savedir="$HOME/.cache"
    local -r lastupdate_saved="$savedir/uc-${renamedos[$os]}-${renamedfile[$file]}"
    local -r lastupdate="${lastupdate_saved}_new"
    local lastupdate_val=""
    local url

    DiscoverUrl

    local -r data=$(curl --fail -Lsm 10 -o- "$url")
    [ "$data" ] || DIE "fetching data from '$url' failed"
    echo "$data" | head -n1 > "$lastupdate"
    lastupdate_val=$(head -n1 $lastupdate)
    case "$os" in
        Arch)        lastupdate_val=$(date --date @$lastupdate_val +%Y%m%d-%H%M.%S) ;;
        EndeavourOS) ;;
    esac

    ShowResult "$url" "$file=$lastupdate_val"

    local ret=$EXIT_UPDATES_NO     # by default, don't expect updates

    [ $reset_history = yes ] && rm -f "$lastupdate_saved"

    if [ -f "$lastupdate_saved" ] ; then
        diff "$lastupdate" "$lastupdate_saved" >/dev/null
        if [ $? -eq 0 ] ; then   # && [ -e $right_after_boot_file ] ; then
            Verbose "no\n"
            rm -f "$lastupdate"
        else
            # touch $right_after_boot_file

            Verbose "maybe\n"  # ... but the updated packages might *not* be installed!
            case "$os" in
                Arch)
                    Verbosex "    %-30s: %s\n" "$lastupdate"       "$(date --date="@$(head -n1 "$lastupdate")")"
                    Verbosex "    %-30s: %s\n" "$lastupdate_saved" "$(date --date="@$(head -n1 "$lastupdate_saved")")"
                    ;;
            esac

            ret=$EXIT_UPDATES_YES
            rm -f "$lastupdate_saved".*                              # delete old update indicators
            # mv "$lastupdate_saved" "$lastupdate_saved".old        || DIE "saving old update indicator failed."
            mv "$lastupdate"       "$lastupdate_saved"            || DIE "saving new update indicator failed."
        fi
    else
        ret=$EXIT_UPDATES_YES       # First time here? Then guess there are updates.
        mv "$lastupdate" "$lastupdate_saved" || DIE "saving first update indicator failed."
        Verbose "${os} updates may be available.\n"
    fi
    return $ret
}

Verbose()  {
    if [ $verbose -ge 1 ] ; then
        local v
        printf -v v "$@"
        out+="$v"
    fi
}
Verbosex() {
    if [ $verbose -ge 2 ] ; then
        local v
        printf -v v "$@"
        out+="$v"
    fi
}

ShowResult() { Verbose "%-s|($2)|:|" "$1" ; }

DIE() {
    printf "%s: error: %s\n\n" "$progname" "$1" >&2
    Usage $EXIT_ERROR
}

Main "$@"
