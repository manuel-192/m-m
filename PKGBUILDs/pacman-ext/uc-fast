#!/bin/bash

# Arch and EndeavourOS update checks using mainly lastupdate and state files.
# Assumption: the lastupdate file is NOT abused by making it equal to lastsync.
# Exit code is similar to 'checkupdates'.

Main() {
    local progname=${0##*/}
    local os
    local ml
    local file
    local verbose=0
    local op=""
    local -r EXIT_UPDATES_YES=0
    local -r EXIT_ERROR=1
    local -r EXIT_UPDATES_NO=2
    local ret_arch=$EXIT_UPDATES_NO
    local ret_eos=$EXIT_UPDATES_NO
    local ret_aur=$EXIT_UPDATES_NO

    [ "$1" ] || Usage $EXIT_ERROR

    # Better handle option --verbose before other options.
    # Option --verbose can be given max 2 times, second time gives even more info.
    for arg in "$@" ; do
        case "$arg" in
            --verbose) [ $verbose -lt 2 ] && ((verbose++)) ;;
        esac
    done

    local lopts=verbose,arch,endeavouros,aur,help
    local sopts=aeyh
    local opts

    opts=$(/bin/getopt -o=$sopts --longoptions=$lopts --name $progname -- "$@") || Usage $EXIT_ERROR
    eval set -- "$opts"

    while true ; do
        case "$1" in
            -a | --arch)
                op="-a"
                os=Arch
                ml=mirrorlist
                file=lastupdate
                Main2 $op
                ret_arch=$?
                ;;
            -e | --endeavouros)
                op="-e"
                os=EndeavourOS
                ml=endeavouros-mirrorlist
                file=state
                Main2 $op
                ret_eos=$?
                ;;
            -y | --aur)
                op="-y"
                Verbose2 "%-70s: " "yay -Qua"
                if yay -Qua >/dev/null ; then
                    ret_aur=$EXIT_UPDATES_YES
                    Verbose2 "AUR updates available.\n"
                else
                    Verbose2 "No AUR updates.\n"
                fi
                ;;
            -h | --help) Usage $EXIT_UPDATES_NO ;;
            --verbose) ;;                             # already handled above
            --) break ;;
            *) Usage $EXIT_ERROR ;;
        esac
        shift
    done
    [ "$op" ] || DIE "operation(s) missing"
    if [ $ret_arch -eq $EXIT_UPDATES_YES ] || [ $ret_eos -eq $EXIT_UPDATES_YES ] || [ $ret_aur -eq $EXIT_UPDATES_YES ] ; then
        exit $EXIT_UPDATES_YES
    fi
    exit $EXIT_UPDATES_NO
}

Usage() {
    cat <<EOF
Usage: $progname [options] {operations}
Options:
    -h, --help           This help.
    --verbose            More verbose output.
Operations:
    -a, --arch           Check Arch package updates.
    -e, --endeavouros    Check EndeavourOS package updates.
    -y, --aur            Check AUR package updates.

EOF
    [ "$1" ] && exit "$1"
}

GetUrlFromMirrorsFile() {
    url=$(grep -m1 "^Server = " /etc/pacman.d/$ml)
    [ "$url" ] || DIE "/etc/pacman.d/$ml has no mirrors configured!"
    url=${url#*= }
}

DiscoverUrl() {
    source /etc/$progname.conf &>/dev/null
    case "$os" in
        EndeavourOS)
            if [ "$EOS_MIRROR" ] ; then
                url="$EOS_MIRROR"
            else
                GetUrlFromMirrorsFile
                url=${url%\$repo/\$arch}$file
            fi
            ;;
        Arch)
            if [ "$ARCH_MIRROR" ] ; then
                url="$ARCH_MIRROR"
            else
                GetUrlFromMirrorsFile
                url=${url%\$repo/os/\$arch}$file
            fi
            ;;
    esac
}

Main2() {
    declare -A renamedos=(
        [EndeavourOS]=x
        [Arch]=y
    )
    declare -A renamedfile=(
        [state]=X
        [lastupdate]=X
    )
    local -r savedir="$HOME/.cache"
    local -r lastupdate_saved="$savedir/uc-${renamedos[$os]}-${renamedfile[$file]}"
    local -r lastupdate="${lastupdate_saved}_new"
    local url

    DiscoverUrl

    Verbose2 "%-70s: " "$url"

    local -r data=$(curl --fail -Lsm 10 -o- "$url")
    [ "$data" ] || DIE "fetching data from '$url' failed"
    echo "$data" | head -n1 > "$lastupdate"

    local ret=$EXIT_UPDATES_NO     # by default, don't expect updates

    if [ -f "$lastupdate_saved" ] ; then
        diff "$lastupdate" "$lastupdate_saved" >/dev/null
        if [ $? -eq 0 ] ; then
            Verbose2 "No ${os} updates.\n"
            rm -f "$lastupdate"
        else
            # Note that the updated packages may *not* be installed here!
            Verbose2 "${os} updates *may* be available.\n"
            case "$os" in
                Arch)
                    Verbose2x "    %-30s: %s\n" "$lastupdate"       "$(date --date="@$(head -n1 "$lastupdate")")"
                    Verbose2x "    %-30s: %s\n" "$lastupdate_saved" "$(date --date="@$(head -n1 "$lastupdate_saved")")"
                    ;;
            esac

            ret=$EXIT_UPDATES_YES
            rm -f "$lastupdate_saved".*                              # delete old update indicators
            # mv "$lastupdate_saved" "$lastupdate_saved".old        || DIE "saving old update indicator failed."
            mv "$lastupdate"       "$lastupdate_saved"            || DIE "saving new update indicator failed."
        fi
    else
        ret=$EXIT_UPDATES_YES       # First time here? Then guess there are updates.
        mv "$lastupdate" "$lastupdate_saved" || DIE "saving first update indicator failed."
        Verbose2 "${os} updates may be available.\n"
    fi
    return $ret
}

Verbose2()  { [ $verbose -ge 1 ] && printf "$@" >&2; }
Verbose2x() { [ $verbose -ge 2 ] && printf "$@" >&2; }

DIE() {
    printf "%s: error: %s\n\n" "$progname" "$1" >&2
    Usage $EXIT_ERROR
}

Main "$@"
