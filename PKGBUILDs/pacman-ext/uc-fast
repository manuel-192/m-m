#!/bin/bash

# Arch and EndeavourOS update checks using mainly lastupdate and state files.
# Assumption: the lastupdate file is NOT abused by making it equal to lastsync.
# Exit code is similar to 'checkupdates'.

Main()
{
    local progname=${0##*/}
    local os
    local ml
    local file
    local verbose=no
    local -r EXIT_UPDATES_YES=0
    local -r EXIT_ERROR=1
    local -r EXIT_UPDATES_NO=2
    local ret_arch=$EXIT_UPDATES_NO
    local ret_eos=$EXIT_UPDATES_NO
    local ret_aur=$EXIT_UPDATES_NO

    [ "$1" ] || Usage $EXIT_ERROR

    for arg in "$@" ; do
        case "$arg" in
            --verbose) verbose=yes ;;      # better handle this option before others
        esac
    done

    local lopts=verbose,arch,endeavouros,aur,help
    local sopts=aeyh
    local opts

    opts=$(/bin/getopt -o=$sopts --longoptions=$lopts --name $progname -- "$@") || Usage $EXIT_ERROR
    eval set -- "$opts"

    while true ; do
        case "$1" in
            -a | --arch)
                os=Arch
                ml=mirrorlist
                file=lastupdate
                Main2 -a
                ret_arch=$?
                ;;
            -e | --endeavouros)
                os=EndeavourOS
                ml=endeavouros-mirrorlist
                file=state
                Main2 -e
                ret_eos=$?
                ;;
            -y | --aur)
                Verbose2 "==> yay -Qua:"
                if yay -Qua >/dev/null ; then
                    ret_aur=$EXIT_UPDATES_YES
                    Verbose2 " -> AUR updates available."
                else
                    Verbose2 " -> No AUR updates."
                fi
                ;;
            -h | --help) Usage $EXIT_UPDATES_NO ;;
            --verbose) ;;                             # already handled above
            --) break ;;
            *) Usage $EXIT_ERROR ;;
        esac
        shift
    done
    if [ $ret_arch -eq $EXIT_UPDATES_YES ] || [ $ret_eos -eq $EXIT_UPDATES_YES ] || [ $ret_aur -eq $EXIT_UPDATES_YES ] ; then
        return $EXIT_UPDATES_YES
    fi
    return $EXIT_UPDATES_NO
}

Usage() {
    cat <<EOF
Usage: $progname [options] {operations}
Options:
    -h, --help           This help.
    --verbose            More verbose output.
Operations:
    -a, --arch           Check Arch package updates.
    -e, --endeavouros    Check EndeavourOS package updates.
    -y, --aur            Check AUR package updates.

EOF
    [ "$1" ] && exit "$1"
}

Main2() {
    declare -A renamedos=(
        [EndeavourOS]=x
        [Arch]=y
    )
    declare -A renamedfile=(
        [state]=X
        [lastupdate]=X
    )
    local lastupdate_saved="/tmp/.uc-${renamedos[$os]}-${renamedfile[$file]}"
    local lastupdate="${lastupdate_saved}.new"
    local url data

    url=$(grep "^Server = " /etc/pacman.d/$ml | head -n1)
    [ "$url" ] || DIE "/etc/pacman.d/$ml has no mirrors configured!"
    url=${url#*= }
    case "$os" in
        EndeavourOS) url=${url%\$repo/\$arch}$file ;;
        Arch)        url=${url%\$repo/os/\$arch}$file ;;
    esac

    Verbose2 "==> Check using $url:"

    data=$(curl --fail -Lsm 10 -o- "$url")
    [ "$data" ] || DIE "fetching data from '$url' failed"
    echo "$data" | head -n1 > "$lastupdate"

    local ret=$EXIT_UPDATES_NO     # by default, don't expect updates

    if [ -f "$lastupdate_saved" ] ; then
        if diff "$lastupdate" "$lastupdate_saved" >/dev/null ; then
            Verbose2 " -> No ${os} updates."
        else
            Verbose2 " -> ${os} updates are available."
            ret=$EXIT_UPDATES_YES
        fi
        rm -f "$lastupdate_saved"
    else
        ret=$EXIT_UPDATES_YES       # First time here? Then guess there are updates.
        Verbose2 " -> ${os} updates may be available."
    fi
    mv "$lastupdate" "$lastupdate_saved" || DIE "saving new update indicator failed."
    return $ret
}

Verbose2() { [ $verbose = yes ] && echo "$@" >&2; }

DIE() {
    echo "$progname: error: $1" >&2
    exit $EXIT_ERROR
}

Main "$@"
